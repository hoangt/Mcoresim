#include "application.h"
#include "defs.h"
#include <iostream>
#include <string>
#include "control_defs.h"
using namespace std;


Define_Module(Application);

void Application::initialize()
{

  tile_id = par("tile_id");
#ifndef NO_DELAY
  delay = 1.0/ ((double)par("clock_rate"));
#else
  delay = 0.0;
#endif
  
  fromProc = gate("fromProc");
  toProc = gate("toProc");
  
  processor_control_in = gateHalf("processor_control",cGate::INPUT);
  processor_control_out = gateHalf("processor_control",cGate::OUTPUT);

  state = APP_STATE_BLOCKED; //the application starts being blocked.

  isActive = false;

  program_counter = 0;
  createProgram();
  return;
}

void Application::handleMessage(cMessage* msg)
{
  if(INCOMING_GATE(msg,fromProc)){
    CAST_MSG(res,msg,Instruction);
    dumpInstruction(res);
    delete msg;
    res = NULL;
    res = nextInstruction();
    if(res == NULL){
      endSimulation();
    }
    sendDelayed(res,delay,toProc);
    //send(res,toProc);
  }
  if(INCOMING_GATE(msg,processor_control_in)){
    CAST_MSG(cntl,msg,ControlMessage);
    switch(cntl->getResponse_code())
    {
      case APP_PROCESSOR_STATE_RUN:
        if(isBlocked()){
          wakeup();
        }
        break;
      case APP_PROCESSOR_STATE_BLOCKED:
        if(isRunning()){
          block();
        }
        break;
    }
    delete msg;
  }
  //chuck the msg. we don't need it anymore, since this was generated by
  //this app in anycase
  return;
}

bool Application::isBlocked()
{
  return (state == APP_STATE_BLOCKED);
}

bool Application::isRunning()
{
  return (state == APP_STATE_RUNNING);
}

void Application::wakeup()
{
  state = APP_STATE_RUNNING;
  if(!isActive){
    cout<<"Starting application!!!"<<endl;
    isActive = true;
    Instruction *first = nextInstruction();
    if(first == NULL){
      endSimulation();
    }
    else{
      sendDelayed(first,delay,toProc);
      //send(first,toProc);
    }
  }
  return;
}

void Application::block()
{
  state = APP_STATE_BLOCKED;
  return;
}

Instruction* Application::nextInstruction()
{
  Instruction *nextIns = NULL;
  if(!theProgram.empty()){
    nextIns = (theProgram.front()).dup();
    program_counter++;
    nextIns->setCounter(program_counter);
    theProgram.pop();
  }
  return nextIns;
}

void Application::createProgram()
{

  //the program goes in here. 
  Instruction inst;
  Instruction *ins;
  ins = &inst;
  
  ins->setOpcode(WRITE);
  ins->setOperand1(0x00);
  ins->setOp_type1(CHAR);
  ins->setOperand2(0xab);
  ins->setOp_type2(CHAR);
  theProgram.push(*ins);

  ins->setOpcode(READ);
  ins->setOperand1(0x00);
  ins->setOp_type1(CHAR);
  ins->setOperand2(0x00);
  theProgram.push(*ins);
  
  ins->setOpcode(WRITE);
  ins->setOperand1(0x01);
  ins->setOp_type1(CHAR);
  ins->setOperand2(0xcd);
  ins->setOp_type2(CHAR);
  theProgram.push(*ins);

  ins->setOpcode(READ);
  ins->setOperand1(0x01);
  ins->setOp_type1(CHAR);
  ins->setOperand2(0x00);
  theProgram.push(*ins);

  return;
}

void Application::dumpInstruction(Instruction *ins)
{
  cout<<"Instruction("<<ins->getCounter()<<","<<ins->getOpcode()<<","<<ins->getOperand1()<<","<<(int)ins->getOperand2()<<")"<<endl; 
  return;
}
